import { CSSProperties } from "vue";
import { Alignment, alignmentToCssPosition } from "./Alignment";
import { borderToStyle, isBorders, type Borders } from "./Border";
import { BorderRadius, borderRadiusToStyle, isBorderRadius } from "./BorderRadius";
import { BoxShadowProps, boxShadowToCSS, isBoxShadow } from "./BoxShadow";
import { px2vw } from "./px2vw";
import { isPlainObject, validateInDev } from "./utils";

export * from "./Gradient";
// export { BorderRadius };
type Valueof<T> = T[keyof T];

// ==========================================================================================
// BoxFit & ImageFit
// ==========================================================================================

export type BoxFit = Valueof<typeof BoxFit>;
export const BoxFit = {
  fitWidth: "fitWidth",
  fitHeight: "fitHeight",
  fill: "fill",
  contain: "contain",
  cover: "cover",
  none: "none",
  scaleDown: "scaleDown",
} as const;

export type ImageRepeat = "repeat" | "repeat-x" | "repeat-y" | "no-repeat";

// 内部使用的 CSS background-size 映射
const ImageFitMap: Record<string, string> = {
  fill: "100% 100%",
  contain: "contain",
  cover: "cover",
  none: "auto", // background-size: auto 是默认值，对应 none
  scaleDown: "contain", // scale-down 行为复杂，CSS background-size 不直接支持，通常近似为 contain 或 auto
  fitWidth: "100% auto",
  fitHeight: "auto 100%",
};

// export type BorderRadiusValue = number;
// export type BorderRadius = BorderRadiusType;
export type Overflow = "none" | "visible" | "hidden" | "scroll" | "auto";

// ==========================================================================================
// Alignment
// ==========================================================================================

const cssPoisitions: Record<string, string> = {
  top: "top",
  bottom: "bottom",
  left: "left",
  right: "right",
  center: "center",
};

// Re-export Alignment for convenience if needed, but primarily use src/Alignment.ts
export type BoxAlignment = Alignment;
export const BoxAlignment = Alignment;

// ==========================================================================================
// BoxShape
// ==========================================================================================

export enum BoxShape {
  rectangle = "rectangle",
  circle = "circle",
}

// ==========================================================================================
// URL Normalization
// ==========================================================================================

let _baseUrl = "";

// 尝试安全地获取 VITE_BASE_URL
try {
  // @ts-expect-error
  if (typeof import.meta !== "undefined" && import.meta.env && import.meta.env.VITE_BASE_URL) {
    // @ts-expect-error
    _baseUrl = import.meta.env.VITE_BASE_URL;
  }
} catch {
  // ignore
}

export function setBaseUrl(url: string) {
  _baseUrl = url;
}

export function normalizeSrc(src: string) {
  if (!src) return "";

  // 1. 绝对路径或特殊协议直接返回
  if (/^(https?:|file:|blob:|data:|\/\/)/i.test(src)) {
    return src;
  }

  // 1.1 CSS Gradient 不处理
  if (/^(linear|radial|conic|repeating-linear|repeating-radial)-gradient\(/.test(src)) {
    return src;
  }

  // 2. 如果没有 base，直接返回
  if (!_baseUrl || _baseUrl === "/") return src;

  // 3. 移除 base 结尾的 slash 和 src 开头的 slash，统一拼接
  const cleanBase = _baseUrl.endsWith("/") ? _baseUrl.slice(0, -1) : _baseUrl;

  if (src.startsWith(cleanBase)) {
    return src;
  }

  const cleanSrc = src.startsWith("/") ? src.slice(1) : src;

  return `${cleanBase}/${cleanSrc}`;
}

export type ImageProvider = string;

export const NetworkImage = (url: string) => url;
export const AssetImage = (url: string) => url;

export interface DecorationImageProps {
  image: ImageProvider;
  fit?: BoxFit;
  alignment?: BoxAlignment;
  repeat?: ImageRepeat;
  blendMode?: string;
  attachment?: string;
  clip?: string;
  origin?: string;
}

export type DecorationImage = DecorationImageProps;

export function DecorationImage(props: DecorationImageProps): DecorationImageProps {
  return props as DecorationImageProps;
}

/**
 * BoxDecoration接口定义
 */
// 定义唯一符号标记
const BOX_DECORATION_SYMBOL = Symbol("boxDecoration");

export type BoxDecorationProps = {
  color?: string;
  border?: Borders;
  borderRadius?: BorderRadius;
  boxShadow?: BoxShadowProps | BoxShadowProps[];
  gradient?: string; // Currently gradient is a CSS string generated by LinearGradient/RadialGradient helpers
  image?: DecorationImageProps;
  overflow?: Overflow;
  opacity?: number;
  shape?: BoxShape;
};

export type BoxDecoration = BoxDecorationProps & {
  [BOX_DECORATION_SYMBOL]?: true;
};

// Re-export BoxShadow for convenience
// export type BoxShadow = BoxShadowProps;

const isGradient = (url: string) =>
  /^(linear|radial|conic|repeating-linear|repeating-radial)-gradient\(/.test(url);

export function decorationImageToStyle(di: DecorationImageProps): CSSProperties {
  if (!di) return {};
  const css: CSSProperties = {};
  const image = normalizeSrc(di.image);
  css.backgroundImage = isGradient(image) ? image : `url(${image})`;

  if (di.fit) {
    // 优先使用映射
    css.backgroundSize = ImageFitMap[di.fit] || di.fit;
  }

  css.backgroundAttachment = di.attachment;
  css.backgroundBlendMode = di.blendMode;
  css.backgroundClip = di.clip;
  css.backgroundOrigin = di.origin;
  css.backgroundRepeat = di.repeat ?? "no-repeat";

  if (di.alignment) {
    // Use unified alignmentToCssPosition
    const position = alignmentToCssPosition(di.alignment as Alignment);
    if (position && position !== "center") {
      css.backgroundPosition = position;
    } else if (di.alignment !== Alignment.center) {
      // Fallback for custom string values if any (legacy support)
      // Check if it's a known alignment key first
      if (Object.keys(Alignment).includes(di.alignment as string)) {
        css.backgroundPosition = alignmentToCssPosition(di.alignment as Alignment);
      } else {
        // Handle custom strings "10px 20px"
        const alignmentStr = (di.alignment as string) || "";
        let [x, y] = alignmentStr.split(" ");
        if (x && !cssPoisitions[x]) x = px2vw(x);
        if (y && !cssPoisitions[y]) y = px2vw(y);
        if (x && !y) y = "center";
        css.backgroundPosition = `${x} ${y}`;
      }
    } else {
      css.backgroundPosition = "center";
    }
  }
  return css;
}

export function boxDecorationToStyle(decoration?: BoxDecorationProps): CSSProperties {
  if (!decoration) return {};
  const { color, border, borderRadius, boxShadow, gradient, image, overflow, opacity, shape } =
    decoration;

  // Validate BoxDecoration sub-properties, only in development mode
  validateInDev(() => {
    if (borderRadius && !isBorderRadius(borderRadius)) {
      console.warn(
        '[BoxDecoration] borderRadius must be created using BorderRadius constructor.\nExample: borderRadius="BorderRadius.circular(10)".',
      );
    }

    if (border && !isBorders(border)) {
      console.warn(
        "[BoxDecoration] border must be created using Border.all or manual BorderSide assignment.\nExample: border=\"Border.all({ color: 'red', width: 1 })\".",
      );
    }

    if (boxShadow) {
      const shadows = Array.isArray(boxShadow) ? boxShadow : [boxShadow];
      shadows.forEach((shadow, index) => {
        if (!isBoxShadow(shadow)) {
          console.warn(
            "[BoxDecoration] boxShadow[" +
              index +
              "] must be created using BoxShadow constructor.\nExample: boxShadow=\"[BoxShadow({ color: 'rgba(0,0,0,0.2)', offset: { x: 2, y: 2 }, blurRadius: 4 })]\".",
          );
        }
      });
    }
  });

  const style: CSSProperties = {};

  if (color) style.backgroundColor = color;
  if (opacity !== undefined) style.opacity = opacity;
  if (overflow) style.overflow = overflow;

  if (gradient) style.backgroundImage = gradient;

  // image 可能会覆盖 gradient，如果两者共存，CSS通常支持多背景，但这里简化处理
  if (image) {
    Object.assign(style, decorationImageToStyle(image));
  }

  if (border) Object.assign(style, borderToStyle(border));

  // Handle BoxShape
  if (shape === BoxShape.circle) {
    style.borderRadius = "50%";
  } else if (borderRadius) {
    Object.assign(style, borderRadiusToStyle(borderRadius));
  }

  if (boxShadow) {
    const shadows = Array.isArray(boxShadow) ? boxShadow : [boxShadow];
    style.boxShadow = shadows.map(boxShadowToCSS).join(", ");
  }

  return style;
}

export function BoxDecoration(props?: BoxDecorationProps): BoxDecoration {
  return {
    ...(props as BoxDecorationProps),
    [BOX_DECORATION_SYMBOL]: true as const,
  };
}

/**
 * 类型守卫：检查对象是否通过 BoxDecoration 构造函数创建
 */
export function isBoxDecoration(value: any): value is BoxDecoration {
  if (!isPlainObject(value)) return false;

  return BOX_DECORATION_SYMBOL in value;
}

// 简单的辅助函数，实际使用可能更复杂

/**
 * Clip
 * 对应 Flutter 的 Clip
 */
export const Clip = {
  none: "none",
  hardEdge: "hardEdge",
  antiAlias: "antiAlias",
  antiAliasWithSaveLayer: "antiAliasWithSaveLayer",
} as const;

export type Clip = keyof typeof Clip;
